============================================================
Temporal Reuse Partitioning & Scheduling
============================================================

[步骤 1] 生成示例 DAG...
DAG 生成完成: 10 个节点, 29 条边
节点资源: [(1, 45), (2, 68), (3, 56), (4, 30), (5, 57), (6, 55), (7, 36), (8, 44), (9, 19), (10, 31)]

[步骤 2] 运行 Algorithm 1 (分区算法)...
============================================================
Algorithm 1: Partition Algorithm (改进 FM)
============================================================

初始分区完成，共 4 个 partition
  Partition 0: nodes=[1, 2], resource=113/150
  Partition 1: nodes=[3, 6, 9], resource=130/150
  Partition 2: nodes=[4, 5, 7], resource=123/150
  Partition 3: nodes=[8, 10], resource=75/150

初始 cutsize: 960

开始 FM 迭代优化...
迭代 1: cutsize = 713 (改善 247)

迭代 2: cutsize = 713 (已改善，收敛)

最终分区结果:
  Partition 0: nodes=[1], resource=45/150
  Partition 1: nodes=[2, 3, 4, 6], resource=209/150
  Partition 2: nodes=[5, 7, 8, 9], resource=156/150
  Partition 3: nodes=[10], resource=31/150
最终 cutsize: 713

分区结果详情:
  Partition 0: [1] (资源: 45/150)
  Partition 1: [2, 3, 4, 6] (资源: 209/150)
  Partition 2: [5, 7, 8, 9] (资源: 156/150)
  Partition 3: [10] (资源: 31/150)
总 cutsize: 713

[步骤 3] 运行 Algorithm 2 (调度算法)...

============================================================
Algorithm 2: Resource-Constrained List Scheduling
============================================================

调度完成，共 14 个 cycle
  Cycle 0: [1, 2]
    Node 1: τ_i=0, τ_o=1
    Node 2: τ_i=10, τ_o=11
  Cycle 1: [3, 6]
    Node 3: τ_i=12, τ_o=13
    Node 6: τ_i=12, τ_o=13
  Cycle 2: [9, 4]
    Node 9: τ_i=20, τ_o=21
    Node 4: τ_i=18, τ_o=19
  Cycle 3: [5, 7]
    Node 5: τ_i=23, τ_o=24
    Node 7: τ_i=28, τ_o=29
  Cycle 4: [8, 10]
    Node 8: τ_i=32, τ_o=33
    Node 10: τ_i=35, τ_o=36
  Cycle 5: [2]
    Node 2: τ_i=10, τ_o=11
  Cycle 6: [3]
    Node 3: τ_i=12, τ_o=13
  Cycle 7: [6]
    Node 6: τ_i=12, τ_o=13
  Cycle 8: [4]
    Node 4: τ_i=18, τ_o=19
  Cycle 9: [9]
    Node 9: τ_i=20, τ_o=21
  Cycle 10: [5]
    Node 5: τ_i=23, τ_o=24
  Cycle 11: [7]
    Node 7: τ_i=28, τ_o=29
  Cycle 12: [8]
    Node 8: τ_i=32, τ_o=33
  Cycle 13: [10]
    Node 10: τ_i=35, τ_o=36

调度结果详情:
  Cycle 0: [1, 2]
  Cycle 1: [3, 6]
  Cycle 2: [9, 4]
  Cycle 3: [5, 7]
  Cycle 4: [8, 10]
  Cycle 5: [2]
  Cycle 6: [3]
  Cycle 7: [6]
  Cycle 8: [4]
  Cycle 9: [9]
  Cycle 10: [5]
  Cycle 11: [7]
  Cycle 12: [8]
  Cycle 13: [10]

节点时间戳:
  Node 1: τ_i = 0, τ_o = 1
  Node 2: τ_i = 10, τ_o = 11
  Node 3: τ_i = 12, τ_o = 13
  Node 4: τ_i = 18, τ_o = 19
  Node 5: τ_i = 23, τ_o = 24
  Node 6: τ_i = 12, τ_o = 13
  Node 7: τ_i = 28, τ_o = 29
  Node 8: τ_i = 32, τ_o = 33
  Node 9: τ_i = 20, τ_o = 21
  Node 10: τ_i = 35, τ_o = 36

[步骤 4] 生成可视化图表...
  DAG 图已保存: ./Implement/Scaling FPGA Capacity via Temporal Reuse/output\dag_partition.png
  甘特图已保存: ./Implement/Scaling FPGA Capacity via Temporal Reuse/output\gantt_chart.png
  Cutsize 曲线已保存: ./Implement/Scaling FPGA Capacity via Temporal Reuse/output\cutsize_iteration.png

============================================================
所有任务完成！
输出文件已保存到: ./Implement/Scaling FPGA Capacity via Temporal Reuse/output/
日志文件: ./Implement/Scaling FPGA Capacity via Temporal Reuse/output\output.txt
============================================================
